#include <iostream>
#include <vector>
#include <stdexcept>

class Vector {
public:

    Vector() : data() {}

    explicit Vector(size_t n) : data(n, 0.0) {}

    size_t size() const { return data.size(); }

    double& operator()(size_t i) {
        if (i >= data.size())
            throw std::out_of_range("Vector index out of bounds");
        return data[i];
    }

    const double& operator()(size_t i) const {
        if (i >= data.size())
            throw std::out_of_range("Vector index out of bounds");
        return data[i];
    }

    Vector operator+(const Vector& other) const {
        if (data.size() != other.data.size())
            throw std::invalid_argument("Vector dimensions must match for addition");
        Vector result(data.size());
        for (size_t i = 0; i < data.size(); ++i)
            result(i) = data[i] + other(i);
        return result;
    }

    Vector operator-(const Vector& other) const {
        if (data.size() != other.data.size())
            throw std::invalid_argument("Vector dimensions must match for subtraction");
        Vector result(data.size());
        for (size_t i = 0; i < data.size(); ++i)
            result(i) = data[i] - other(i);
        return result;
    }

    double dot(const Vector& other) const {
        if (data.size() != other.data.size())
            throw std::invalid_argument("Vector dimensions must match for dot product");
        double sum = 0.0;
        for (size_t i = 0; i < data.size(); ++i)
            sum += data[i] * other(i);
        return sum;
    }


    Vector cross(const Vector& other) const {
        if (data.size() != 3 || other.data.size() != 3)
            throw std::invalid_argument("Cross product is defined only for 3D vectors");
        Vector result(3);
        result(0) = data[1] * other(2) - data[2] * other(1);
        result(1) = data[2] * other(0) - data[0] * other(2);
        result(2) = data[0] * other(1) - data[1] * other(0);
        return result;
    }

    void print() const {
        for (size_t i = 0; i < data.size(); ++i)
            std::cout << data[i] << " ";
        std::cout << std::endl;
    }

private:
    std::vector<double> data;
};


class Matrix
{
public:

    // constructor: Initialize matrix with given rows and columns
    // initialize with zeros
    Matrix(size_t r, size_t c) : rows(r), cols(c) {
        data.resize(rows, std::vector< double >(cols, 0.0));
    }

    // overload () operator for element access (e.g., matrix(i, j))
    double& operator()(size_t i, size_t j) {
        if (i >= rows || j >= cols) {
            throw std::out_of_range("Matrix index out of bounds");
        }
        return data[i][j];
    }

    // Const version of () operator for read-only access
    const double& operator()(size_t i, size_t j) const {
        if (i >= rows || j >= cols) {
            throw std::out_of_range("Matrix index out of bounds");
        }
        return data[i][j];
    }

    // Get number of rows
    size_t getRows() const { return rows; }

    // Get number of columns
    size_t getCols() const { return cols; }

    // overload + operator for matrix addition
    Matrix operator+(const Matrix& other) const {
        if (rows != other.rows || cols != other.cols) {
            throw std::invalid_argument("Matrix dimensions must match for addition");
        }
        Matrix result(rows, cols);
        for (size_t i = 0; i < rows; ++i) {
            for (size_t j = 0; j < cols; ++j) {
                result(i, j) = data[i][j] + other(i, j);
            }
        }
        return result;
    }

    // overload * operator for matrix multiplication
    Matrix operator*(const Matrix& other) const {
        if (cols != other.rows) {
            throw std::invalid_argument("Matrix dimensions incompatible for multiplication");
        }
        Matrix result(rows, other.cols);
        for (size_t i = 0; i < rows; ++i) {
            for (size_t j = 0; j < other.cols; ++j) {
                for (size_t k = 0; k < cols; ++k) {
                    result(i, j) += data[i][k] * other(k, j);
                }
            }
        }
        return result;
    }

    Vector operator*(const Vector& v) const {
        if (cols != v.size())
            throw std::invalid_argument("Matrix columns must match vector size");

        Vector result(rows);
        for (size_t i = 0; i < rows; ++i) {
            double sum = 0.0;
            for (size_t j = 0; j < cols; ++j)
                sum += data[i][j] * v(j);
            result(i) = sum;
        }
        return result;
    }

    // print matrix (for debugging/display)
    void print() const {
        for (size_t i = 0; i < rows; ++i) {
            for (size_t j = 0; j < cols; ++j) {
                std::cout << data[i][j] << " ";
            }
            std::cout << std::endl;
        }
    }

private:

    size_t rows, cols;                          // dimensions of the matrix
    std::vector< std::vector< double > > data;  // 2D vector to store matrix elements

};

// Example usage
int main() {

    try {

        Vector a(3), b(3);
        a(0) = 1; a(1) = 2; a(2) = 3;
        b(0) = 4; b(1) = 5; b(2) = 6;

        std::cout << "Vector a: "; a.print();
        std::cout << "Vector b: "; b.print();

        std::cout << "a + b: "; (a + b).print();
        std::cout << "a - b: "; (a - b).print();
        std::cout << "Dot product (a·b): " << a.dot(b) << std::endl;
        std::cout << "Cross product (a×b): "; a.cross(b).print();

        // Create two 2x2 matrices
        Matrix A(2, 2), B(2, 2);

        // Initialize matrix A
        A(0, 0) = 1; A(0, 1) = 2;
        A(1, 0) = 3; A(1, 1) = 4;

        // Initialize matrix B
        B(0, 0) = 5; B(0, 1) = 6;
        B(1, 0) = 7; B(1, 1) = 8;

        // Test matrix addition
        std::cout << "Matrix A:" << std::endl;
        A.print();
        std::cout << "Matrix B:" << std::endl;
        B.print();

        std::cout << "A + B:" << std::endl;
        Matrix C = A + B;
        C.print();

        // Test matrix multiplication
        std::cout << "A * B:" << std::endl;
        Matrix D = A * B;
        D.print();

        // Test error handling
        Matrix E(2, 3); // Incompatible for multiplication with A
        Matrix F = A * E; // Should throw exception

        Matrix M(3, 3);
        M(0, 0) = 1; M(0, 1) = 2; M(0, 2) = 3;
        M(1, 0) = 4; M(1, 1) = 5; M(1, 2) = 6;
        M(2, 0) = 7; M(2, 1) = 8; M(2, 2) = 9;

        std::cout << "Matrix M:" << std::endl;
        M.print();

        std::cout << "M * a:" << std::endl;
        Vector result = M * a;
        result.print();

    }
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
